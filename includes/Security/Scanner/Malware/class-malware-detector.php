<?php

namespace WP_Security\Scanner\Malware;

use WP_Security\Scanner\Base\AbstractScanner;
use WP_Security\Scanner\Base\ScanResult;
use WP_Security\Monitoring\Resource\Exception\ResourceLimitException;
use WP_Security\Scanner\Core\CoreFileManager;
use WP_Security\Scanner\Analysis\CodeAnalyzer;
use WP_Security\Monitoring\Resource\ResourceManager;
use WP_Security\Scanner\Malware\ThreatPatternManager;

if ( ! defined( 'ABSPATH' ) ) {
	die( 'Direct access not permitted.' );
}

class MalwareDetector extends AbstractScanner {
	private $core_manager;
	private $code_analyzer;
	private $pattern_manager;
	private $log_file;
	private $scanStartTime;

	public function __construct( $logger ) {
		parent::__construct( $logger );
		$this->core_manager    = new CoreFileManager( $logger );
		$this->code_analyzer   = new CodeAnalyzer( $logger );
		$this->pattern_manager = new ThreatPatternManager();
		$this->log_file        = WP_CONTENT_DIR . '/security/malware_scan.log';

		// Ensure log directory exists
		wp_mkdir_p( dirname( $this->log_file ) );

		// Add WordPress hooks
		add_action( 'wp_security_scan_file', array( $this, 'scan_file' ), 10, 2 );
		add_action( 'upgrade_plugin', array( $this, 'scan_plugin_update' ), 10, 2 );
		add_action( 'upgrader_process_complete', array( $this, 'scan_after_update' ), 10, 2 );
		add_action( 'activate_plugin', array( $this, 'scan_plugin_activation' ) );
		add_action( 'switch_theme', array( $this, 'scan_theme_switch' ) );

		// Add upload scanning
		add_filter( 'wp_handle_upload', array( $this, 'scan_upload' ) );

		// Schedule daily scan using WP Cron
		if ( ! wp_next_scheduled( 'wp_security_daily_scan' ) ) {
			wp_schedule_event( time(), 'daily', 'wp_security_daily_scan' );
		}
		add_action( 'wp_security_daily_scan', array( $this, 'run_scheduled_scan' ) );
	}

	public function schedule_scan() {
		if ( ! wp_next_scheduled( 'wp_security_malware_scan' ) ) {
			wp_schedule_event( time(), 'daily', 'wp_security_malware_scan' );
		}
		add_action( 'wp_security_malware_scan', array( $this, 'run_scheduled_scan' ) );
	}

	public function run_scheduled_scan() {
		try {
			$result = $this->scan_and_clean();
			$this->log_scan_result( $result );
		} catch ( \Exception $e ) {
			$this->logger->error(
				'Scheduled malware scan failed',
				array(
					'error' => $e->getMessage(),
				)
			);
		}
	}

	private function log_scan_result( ScanResult $result ) {
		$log_data = sprintf(
			"[%s] Scan completed: Checked %d files, Removed %d malicious files, Restored %d core files, Checked %d database rows\n",
			date( 'Y-m-d H:i:s' ),
			$result->getMetadata( 'files_checked' ),
			$result->getMetadata( 'files_removed' ),
			$result->getMetadata( 'files_restored' ),
			$result->getMetadata( 'db_rows_checked' )
		);

		foreach ( $result->getThreats() as $threat ) {
			$log_data .= sprintf(
				"[%s] %s: %s\n",
				date( 'Y-m-d H:i:s' ),
				$threat['type'],
				$threat['file']
			);
		}

		file_put_contents( $this->log_file, $log_data, FILE_APPEND );
	}

	public function scan_and_clean(): ScanResult {
		$this->scanStartTime = time();
		$result              = new ScanResult( 'malware_scan' );
		$files_checked       = 0;
		$files_removed       = 0;
		$files_restored      = 0;
		$db_rows_checked     = 0;

		try {
			// First scan files
			$this->scan_files( $result, $files_checked, $files_removed, $files_restored );

			// Then scan database
			$this->scan_database( $result, $db_rows_checked );

			$result->addMetadata( 'files_checked', $files_checked );
			$result->addMetadata( 'files_removed', $files_removed );
			$result->addMetadata( 'files_restored', $files_restored );
			$result->addMetadata( 'db_rows_checked', $db_rows_checked );
			$result->addMetadata( 'scan_time', time() - $this->scanStartTime );
			$result->addMetadata( 'resource_usage', $this->getResourceUsage() );

			return $result->complete();

		} catch ( ResourceLimitException $e ) {
			$this->logger->warning(
				'Scan interrupted due to resource limits',
				array(
					'error'           => $e->getMessage(),
					'files_checked'   => $files_checked,
					'db_rows_checked' => $db_rows_checked,
					'resource_usage'  => $this->getResourceUsage(),
				)
			);

			$result->addMetadata( 'files_checked', $files_checked );
			$result->addMetadata( 'files_removed', $files_removed );
			$result->addMetadata( 'files_restored', $files_restored );
			$result->addMetadata( 'db_rows_checked', $db_rows_checked );
			$result->addMetadata( 'scan_time', time() - $this->scanStartTime );
			$result->addMetadata( 'resource_usage', $this->getResourceUsage() );
			$result->addMetadata( 'interrupted', true );
			$result->addMetadata( 'interrupt_reason', $e->getMessage() );

			return $result->complete();

		} catch ( \Exception $e ) {
			$this->logger->error(
				'Malware scan failed',
				array(
					'error'           => $e->getMessage(),
					'files_checked'   => $files_checked,
					'db_rows_checked' => $db_rows_checked,
					'resource_usage'  => $this->getResourceUsage(),
				)
			);
			throw $e;
		}
	}

	/**
	 * Scan files for malware
	 *
	 * @param ScanResult $result Scan result object
	 * @param int        $files_checked Reference to files checked counter
	 * @param int        $files_removed Reference to files removed counter
	 * @param int        $files_restored Reference to files restored counter
	 */
	private function scan_files( ScanResult &$result, int &$files_checked, int &$files_removed, int &$files_restored ): void {
		$iterator = new \RecursiveIteratorIterator(
			new \RecursiveDirectoryIterator( ABSPATH, \RecursiveDirectoryIterator::SKIP_DOTS )
		);

		foreach ( $iterator as $file ) {
			++$files_checked;

			// Check resource limits every 500 files or when memory usage is high
			if ( $files_checked % 500 === 0 || memory_get_usage( true ) > 64 * 1024 * 1024 ) {
				$this->checkResourceLimits(
					array(
						'time'            => time() - $this->scanStartTime,
						'memory'          => memory_get_usage( true ),
						'files_processed' => $files_checked,
					)
				);
			}

			// First check if it's a core file that needs restoration
			if ( $this->core_manager->verify_and_restore( $file->getPathname() ) ) {
				++$files_restored;
				$result->addThreat(
					'core_file_restored',
					$file->getPathname(),
					array(
						'type'   => 'core_file',
						'action' => 'restored',
					)
				);
				continue;
			}

			// Then check for malicious files
			if ( $this->is_suspicious_file( $file ) ) {
				// Analyze suspicious files before removal
				$analysis = $this->code_analyzer->analyze_file( $file->getPathname() );
				if ( $analysis['threats_found'] > 0 || $file->getSize() === 0 ) {
					if ( unlink( $file->getPathname() ) ) {
						++$files_removed;
						$result->addThreat(
							'malicious_file_removed',
							$file->getPathname(),
							array(
								'size'     => $file->getSize(),
								'type'     => 'malicious_file',
								'action'   => 'removed',
								'analysis' => $analysis,
							)
						);
						$this->logger->info(
							'Malicious file removed',
							array(
								'file'     => $file->getPathname(),
								'size'     => $file->getSize(),
								'analysis' => $analysis,
							)
						);
					}
				}
			}
		}
	}

	/**
	 * Scan database for malware
	 *
	 * @param ScanResult $result Scan result object
	 * @param int        $db_rows_checked Reference to rows checked counter
	 */
	private function scan_database( ScanResult &$result, int &$db_rows_checked ): void {
		global $wpdb;

		// Get all tables
		$tables = $wpdb->get_col( "SHOW TABLES LIKE '{$wpdb->prefix}%'" );

		foreach ( $tables as $table ) {
			// Get optimal batch size based on current memory usage
			$batch_size = $this->resource_manager->getOptimalBatchSize();
			$offset     = 0;

			do {
				// Get batch of rows
				$rows = $wpdb->get_results(
					$wpdb->prepare(
						"SELECT * FROM {$table} LIMIT %d OFFSET %d",
						$batch_size,
						$offset
					),
					ARRAY_A
				);

				if ( ! empty( $rows ) ) {
					foreach ( $rows as $row ) {
						++$db_rows_checked;

						// Check for malicious content in text/longtext columns
						foreach ( $row as $column => $value ) {
							if ( is_string( $value ) && strlen( $value ) > 32 ) {
								$analysis = $this->code_analyzer->analyze_content( $value );
								if ( $analysis['threats_found'] > 0 ) {
									$result->addThreat(
										'malicious_db_content',
										"{$table}.{$column}",
										array(
											'type'     => 'database',
											'table'    => $table,
											'column'   => $column,
											'row_id'   => $row['ID'] ?? null,
											'analysis' => $analysis,
										)
									);
								}
							}
						}
					}

					// Check resource limits and update progress
					$this->resource_manager->checkDatabase(
						array(
							'rows_processed' => count( $rows ),
						)
					);
				}

				$offset += $batch_size;

			} while ( ! empty( $rows ) );
		}
	}

	private function is_suspicious_file( \SplFileInfo $file ): bool {
		return $this->pattern_manager->is_suspicious_file( $file );
	}

	/**
	 * Scan a file for malware
	 *
	 * @param string $file_path Path to file
	 * @param array  $context   Scan context
	 * @return array Scan results
	 */
	public function scan_file( $file_path, $context = array() ) {
		// Allow other plugins to skip files
		if ( ! apply_filters( 'wp_security_should_scan_file', true, $file_path, $context ) ) {
			return array();
		}

		$results = array();

		// Use WP Filesystem API
		require_once ABSPATH . 'wp-admin/includes/file.php';
		WP_Filesystem();
		global $wp_filesystem;

		if ( ! $wp_filesystem->exists( $file_path ) ) {
			return $results;
		}

		$content = $wp_filesystem->get_contents( $file_path );

		// Allow other plugins to modify content before scanning
		$content = apply_filters( 'wp_security_pre_scan_content', $content, $file_path );

		// Scan content
		$patterns = apply_filters( 'wp_security_malware_patterns', $this->pattern_manager->get_patterns() );

		foreach ( $patterns as $pattern ) {
			if ( preg_match( $pattern['regex'], $content, $matches ) ) {
				$results[] = array(
					'file'        => $file_path,
					'pattern'     => $pattern['name'],
					'match'       => $matches[0],
					'description' => $pattern['description'],
				);
			}
		}

		// Allow modification of results
		$results = apply_filters( 'wp_security_scan_results', $results, $file_path, $content );

		if ( ! empty( $results ) ) {
			do_action( 'wp_security_malware_found', $results, $file_path );
		}

		return $results;
	}

	/**
	 * Scan plugin after update
	 */
	public function scan_plugin_update( $plugin_file, $plugin_data ) {
		$plugin_dir = WP_PLUGIN_DIR . '/' . dirname( $plugin_file );
		do_action( 'wp_security_before_plugin_scan', $plugin_file, $plugin_data );
		$this->scan_directory( $plugin_dir );
		do_action( 'wp_security_after_plugin_scan', $plugin_file, $plugin_data );
	}

	/**
	 * Scan uploads
	 */
	public function scan_upload( $file ) {
		if ( ! apply_filters( 'wp_security_should_scan_upload', true, $file ) ) {
			return $file;
		}

		$results = $this->scan_file( $file['file'], array( 'context' => 'upload' ) );

		if ( ! empty( $results ) ) {
			// Use wp_handle_upload_error filter to block malicious uploads
			$file['error'] = new WP_Error(
				'security_threat_detected',
				__( 'Security threat detected in upload', 'wp-security-hardening' )
			);
		}

		return $file;
	}

	/**
	 * Run scheduled scan
	 */
	public function run_scheduled_scan() {
		if ( ! apply_filters( 'wp_security_should_run_scheduled_scan', true ) ) {
			return;
		}

		$scan_locations = apply_filters(
			'wp_security_scan_locations',
			array(
				WP_PLUGIN_DIR,
				WP_CONTENT_DIR . '/themes',
				WP_CONTENT_DIR . '/uploads',
			)
		);

		foreach ( $scan_locations as $location ) {
			$this->scan_directory( $location );
		}

		do_action( 'wp_security_scheduled_scan_complete' );
	}

	/**
	 * Scan a directory for malware
	 *
	 * @param string $directory Path to directory
	 */
	private function scan_directory( $directory ) {
		$iterator = new \RecursiveIteratorIterator(
			new \RecursiveDirectoryIterator( $directory, \RecursiveDirectoryIterator::SKIP_DOTS )
		);

		foreach ( $iterator as $file ) {
			$results = $this->scan_file( $file->getPathname() );

			if ( ! empty( $results ) ) {
				do_action( 'wp_security_malware_found', $results, $file->getPathname() );
			}
		}
	}
}
